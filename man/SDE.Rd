% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sde.R
\name{SDE}
\alias{SDE}
\title{R6 class for stochastic differential equation}
\description{
R6 class for stochastic differential equation

R6 class for stochastic differential equation
}
\details{
Contains the model formulas and data.

This creates an attribute \code{tmb_obj}, which can be used to 
evaluate the negative log-likelihood function.


This applies \code{check_fn} to the observed data (returned by 
\code{data()} method) to obtain observed statistics. It then repeatedly
simulates a realisation from the fitted SDE (based on observed covariates),
and applies \code{check_fn} to the simulated data. The simulations use
the \code{posterior = TRUE} option from the code{simulate} method, i.e., 
parameters of model used for simulation are generated from posterior
distribution.
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-SDE-new}{\code{SDE$new()}}
\item \href{#method-SDE-formulas}{\code{SDE$formulas()}}
\item \href{#method-SDE-data}{\code{SDE$data()}}
\item \href{#method-SDE-type}{\code{SDE$type()}}
\item \href{#method-SDE-response}{\code{SDE$response()}}
\item \href{#method-SDE-fixpar}{\code{SDE$fixpar()}}
\item \href{#method-SDE-map}{\code{SDE$map()}}
\item \href{#method-SDE-mats}{\code{SDE$mats()}}
\item \href{#method-SDE-other_data}{\code{SDE$other_data()}}
\item \href{#method-SDE-link}{\code{SDE$link()}}
\item \href{#method-SDE-invlink}{\code{SDE$invlink()}}
\item \href{#method-SDE-coeff_fe}{\code{SDE$coeff_fe()}}
\item \href{#method-SDE-coeff_re}{\code{SDE$coeff_re()}}
\item \href{#method-SDE-lambda}{\code{SDE$lambda()}}
\item \href{#method-SDE-sdev}{\code{SDE$sdev()}}
\item \href{#method-SDE-rho}{\code{SDE$rho()}}
\item \href{#method-SDE-terms}{\code{SDE$terms()}}
\item \href{#method-SDE-out}{\code{SDE$out()}}
\item \href{#method-SDE-tmb_obj}{\code{SDE$tmb_obj()}}
\item \href{#method-SDE-tmb_obj_joint}{\code{SDE$tmb_obj_joint()}}
\item \href{#method-SDE-tmb_rep}{\code{SDE$tmb_rep()}}
\item \href{#method-SDE-obs}{\code{SDE$obs()}}
\item \href{#method-SDE-X_re_decay}{\code{SDE$X_re_decay()}}
\item \href{#method-SDE-update_coeff_fe}{\code{SDE$update_coeff_fe()}}
\item \href{#method-SDE-update_coeff_re}{\code{SDE$update_coeff_re()}}
\item \href{#method-SDE-update_lambda}{\code{SDE$update_lambda()}}
\item \href{#method-SDE-update_rho}{\code{SDE$update_rho()}}
\item \href{#method-SDE-make_mat}{\code{SDE$make_mat()}}
\item \href{#method-SDE-make_mat_grid}{\code{SDE$make_mat_grid()}}
\item \href{#method-SDE-setup}{\code{SDE$setup()}}
\item \href{#method-SDE-fit}{\code{SDE$fit()}}
\item \href{#method-SDE-linear_predictor}{\code{SDE$linear_predictor()}}
\item \href{#method-SDE-par}{\code{SDE$par()}}
\item \href{#method-SDE-post_coeff}{\code{SDE$post_coeff()}}
\item \href{#method-SDE-post_par}{\code{SDE$post_par()}}
\item \href{#method-SDE-CI_pointwise}{\code{SDE$CI_pointwise()}}
\item \href{#method-SDE-CI_simultaneous}{\code{SDE$CI_simultaneous()}}
\item \href{#method-SDE-residuals}{\code{SDE$residuals()}}
\item \href{#method-SDE-check_post}{\code{SDE$check_post()}}
\item \href{#method-SDE-AIC_conditional}{\code{SDE$AIC_conditional()}}
\item \href{#method-SDE-AIC_marginal}{\code{SDE$AIC_marginal()}}
\item \href{#method-SDE-edf_conditional}{\code{SDE$edf_conditional()}}
\item \href{#method-SDE-simulate}{\code{SDE$simulate()}}
\item \href{#method-SDE-plot_par}{\code{SDE$plot_par()}}
\item \href{#method-SDE-plot_violin_coeff}{\code{SDE$plot_violin_coeff()}}
\item \href{#method-SDE-plot_violin_par}{\code{SDE$plot_violin_par()}}
\item \href{#method-SDE-plot_fe_par_2D}{\code{SDE$plot_fe_par_2D()}}
\item \href{#method-SDE-plot_me_par_2D}{\code{SDE$plot_me_par_2D()}}
\item \href{#method-SDE-plot_fe_par_3D}{\code{SDE$plot_fe_par_3D()}}
\item \href{#method-SDE-get_all_plots}{\code{SDE$get_all_plots()}}
\item \href{#method-SDE-ind_fixcoeff}{\code{SDE$ind_fixcoeff()}}
\item \href{#method-SDE-eqn}{\code{SDE$eqn()}}
\item \href{#method-SDE-message}{\code{SDE$message()}}
\item \href{#method-SDE-print_par}{\code{SDE$print_par()}}
\item \href{#method-SDE-print}{\code{SDE$print()}}
\item \href{#method-SDE-stationary}{\code{SDE$stationary()}}
\item \href{#method-SDE-clone}{\code{SDE$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-new"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-new}{}}}
\subsection{Method \code{new()}}{
Create a SDE object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$new(
  formulas = NULL,
  data,
  type,
  response,
  par0 = NULL,
  fixpar = NULL,
  other_data = NULL,
  map = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{formulas}}{List of formulas for model parameters, with one element
for each SDE parameter. Formulas can use standard R syntax, as well
as mgcv-style syntax for splines and random effects.}

\item{\code{data}}{Data frame with covariates, response variable,
time, and ID}

\item{\code{type}}{Type of SDE. Options are "BM" (Brownian motion), "OU" (Ornstein-
Uhlenbeck process), "CTCRW" (continuous-time correlated random walk, a.k.a.
integrated Ornstein-Uhlenbeck process), "CIR" (Cox-Ingersoll-Ross process),
"BM_SSM" (BM with measurement error), "OU_SSM" (OU with measurement error),
"BM_t" (BM with Student's t-distributed increments) and "RACVM" (Rotational correlated
velocity model with drift).}

\item{\code{response}}{Name of response variable, correspond to a column name in
\code{data}. Can be a vector of names if multiple response variables}

\item{\code{par0}}{Vector of initial values for SDE parameters, with one value
for each SDE parameter. If not provided, parameters are initialised to
zero on the link scale.}

\item{\code{fixpar}}{Vector of names of fixed SDE parameters}

\item{\code{other_data}}{Named list of data objects to pass to likelihood, only
required for special models}

\item{\code{map}}{list with element names that are a subset "coeff_re","coeff_fe","log_lambda",
used to fix specific coefficients in the model
(see TMB documentation https://search.r-project.org/CRAN/refmans/TMB/html/MakeADFun.html for more details)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new SDE object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-formulas"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-formulas}{}}}
\subsection{Method \code{formulas()}}{
Formulas of SDE object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$formulas()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-data"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-data}{}}}
\subsection{Method \code{data()}}{
Data of SDE object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$data()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-type"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-type}{}}}
\subsection{Method \code{type()}}{
Type of SDE object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$type()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-response"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-response}{}}}
\subsection{Method \code{response()}}{
Name(s) of response variable(s)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$response()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-fixpar"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-fixpar}{}}}
\subsection{Method \code{fixpar()}}{
Name(s) of fixed parameter(s)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$fixpar()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-map"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-map}{}}}
\subsection{Method \code{map()}}{
Map for fixed coefficient(s)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$map()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-mats"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-mats}{}}}
\subsection{Method \code{mats()}}{
List of model matrices (X_fe, X_re, and S)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$mats()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-other_data"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-other_data}{}}}
\subsection{Method \code{other_data()}}{
Named list of additional data objects
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$other_data()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-link"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-link}{}}}
\subsection{Method \code{link()}}{
Link functions
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$link()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-invlink"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-invlink}{}}}
\subsection{Method \code{invlink()}}{
Inverse link functions
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$invlink()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-coeff_fe"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-coeff_fe}{}}}
\subsection{Method \code{coeff_fe()}}{
Fixed effect parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$coeff_fe()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-coeff_re"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-coeff_re}{}}}
\subsection{Method \code{coeff_re()}}{
Random effect parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$coeff_re()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-lambda"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-lambda}{}}}
\subsection{Method \code{lambda()}}{
Smoothness parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$lambda()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-sdev"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-sdev}{}}}
\subsection{Method \code{sdev()}}{
Standard deviations of smooth terms

This function transforms the smoothness parameter of
each smooth term into a standard deviation, given by 
SD = 1/sqrt(lambda). It is particularly helpful to get the
standard deviations of independent normal random effects.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$sdev()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-rho"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-rho}{}}}
\subsection{Method \code{rho()}}{
Decay parameter
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$rho()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-terms"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-terms}{}}}
\subsection{Method \code{terms()}}{
Terms of model formulas
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$terms()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-out"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-out}{}}}
\subsection{Method \code{out()}}{
Output of optimiser after model fitting
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$out()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-tmb_obj"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-tmb_obj}{}}}
\subsection{Method \code{tmb_obj()}}{
Model object created by TMB. This is the output of 
the TMB function \code{MakeADFun}, and it is a list including elements
\itemize{
  \item{\code{fn}}{Objective function}
  \item{\code{gr}}{Gradient function of fn}
  \item{\code{par}}{Vector of initial parameters on working scale}
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$tmb_obj()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-tmb_obj_joint"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-tmb_obj_joint}{}}}
\subsection{Method \code{tmb_obj_joint()}}{
Model object created by TMB for the joint likelihood of
the fixed and random effects. This is the output of the TMB function 
\code{MakeADFun}, and it is a list including elements
\itemize{
  \item{\code{fn}}{Objective function}
  \item{\code{gr}}{Gradient function of fn}
  \item{\code{par}}{Vector of initial parameters on working scale}
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$tmb_obj_joint()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-tmb_rep"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-tmb_rep}{}}}
\subsection{Method \code{tmb_rep()}}{
Output of the TMB function \code{sdreport}, which includes 
estimates and standard errors for all model parameters.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$tmb_rep()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-obs"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-obs}{}}}
\subsection{Method \code{obs()}}{
Data frame of observations (subset response
variables out of full data frame)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$obs()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-X_re_decay"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-X_re_decay}{}}}
\subsection{Method \code{X_re_decay()}}{
Get design matrix for random effects in decay model

The design matrix is obtained by taking X_re (returned by 
make_mat), and multiplying the relevant columns by something like
exp(-rho * time) to force the splines to decay to zero with a rate
determined by rho.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$X_re_decay()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Design matrix
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-update_coeff_fe"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-update_coeff_fe}{}}}
\subsection{Method \code{update_coeff_fe()}}{
Update fixed effect coefficients
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$update_coeff_fe(new_coeff)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{new_coeff}}{New coefficient vector}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-update_coeff_re"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-update_coeff_re}{}}}
\subsection{Method \code{update_coeff_re()}}{
Update random effect coefficients
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$update_coeff_re(new_coeff)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{new_coeff}}{New coefficient vector}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-update_lambda"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-update_lambda}{}}}
\subsection{Method \code{update_lambda()}}{
Update smoothness parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$update_lambda(new_lambda)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{new_lambda}}{New smoothness parameter vector}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-update_rho"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-update_rho}{}}}
\subsection{Method \code{update_rho()}}{
Update decay parameter
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$update_rho(new_rho)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{new_rho}}{New decay parameter vector}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-make_mat"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-make_mat}{}}}
\subsection{Method \code{make_mat()}}{
Create model matrices
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$make_mat(new_data = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{new_data}}{Optional new data set, including covariates for which
the design matrices should be created.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of
\itemize{
  \item X_fe Design matrix for fixed effects
  \item X_re Design matrix for random effects
  \item S Smoothness matrix
  \item ncol_fe Number of columns for X_fe for each parameter
  \item start_ncol_re Indexes for start of columns of X_re and S matching each random effect
  \item end_ncol_re Indexes for end of columns of X_re and S matching each random effect
}
Design matrices for grid of covariates
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-make_mat_grid"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-make_mat_grid}{}}}
\subsection{Method \code{make_mat_grid()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$make_mat_grid(var, covs = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{var}}{Name of variable}

\item{\code{covs}}{Optional data frame with a single row and one column
for each covariate, giving the values that should be used. If this is
not specified, the mean value is used for numeric variables, and the
first level for factor variables.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the same elements as the output of make_mat, 
plus a data frame of covariates values.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-setup"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-setup}{}}}
\subsection{Method \code{setup()}}{
TMB setup
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$setup(silent = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{silent}}{Logical. If TRUE, all tracing outputs are hidden (default).}

\item{\code{map}}{List passed to MakeADFun to fix parameters. (See TMB documentation.)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-fit"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-fit}{}}}
\subsection{Method \code{fit()}}{
Model fitting

The negative log-likelihood of the model is minimised using the
function \code{optim}. TMB uses the Laplace approximation to integrate 
the random effects out of the likelihood.

After the model has been fitted, the output of \code{optim} can be
accessed using the method \code{res}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$fit(silent = TRUE, method = "BFGS", lower = -Inf, upper = Inf)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{silent}}{Logical. If TRUE, all tracing outputs are hidden (default).}

\item{\code{method}}{String. Method used for optimization using optim R function}

\item{\code{lower}}{Numeric vector. Used to define bounds on parameters in optimization with optim R function}

\item{\code{upper}}{NUmeric vector. Used to define bounds on parameters in optimization with optim R function}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-linear_predictor"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-linear_predictor}{}}}
\subsection{Method \code{linear_predictor()}}{
Get linear predictor for SDE parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$linear_predictor(
  new_data = NULL,
  t = "all",
  X_fe = NULL,
  X_re = NULL,
  coeff_fe = NULL,
  coeff_re = NULL,
  term = NULL,
  re_index = NULL,
  ignore_re = FALSE,
  ignore_fe = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{new_data}}{Optional data set of covariates. If \code{new_data},
\code{X_fe} and \code{X_re} are not provided, then the observed 
covariates are used.}

\item{\code{t}}{Time points for which the parameters should be returned.
If "all", returns parameters for all time steps (default).}

\item{\code{X_fe}}{Optional design matrix for fixed effects, as returned
by \code{make_mat}. If \code{new_data}, \code{X_fe} and \code{X_re} 
are not provided, then the observed covariates are used.}

\item{\code{X_re}}{Optional design matrix for random effects, as returned
by \code{make_mat}. If \code{new_data}, \code{X_fe} and \code{X_re} 
are not provided, then the observed covariates are used.}

\item{\code{coeff_fe}}{Optional vector of fixed effect parameters}

\item{\code{coeff_re}}{Optional vector of random effect parameters}

\item{\code{term}}{Name of model term as character string, e.g., "time", 
or "s(time)". Use \code{$coeff_fe()} and \code{$coeff_re()} methods
to find names of model terms. This uses fairly naive substring 
matching, and may not work if one covariate's name is a 
substring of another one.}

\item{\code{re_index}}{index of terms we want to keep in the random effects matrix and coeffs
May creat conflicts with param "term" if it is not null.}

\item{\code{ignore_re}}{whether or not to ignore the random effects in the linear predictor}

\item{\code{ignore_fe}}{whether or not to ignore the fixed effects (intercepts)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Matrix of linear predictor 
(X_fe %*% coeff_fe + X_re %*% coeff_re) 
with one row for each time step and one column for each SDE parameter
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-par"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-par}{}}}
\subsection{Method \code{par()}}{
Get SDE parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$par(
  t = NULL,
  new_data = NULL,
  X_fe = NULL,
  X_re = NULL,
  coeff_fe = NULL,
  coeff_re = NULL,
  resp = TRUE,
  term = NULL,
  re_index = NULL,
  ignore_re = FALSE,
  ignore_fe = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{t}}{Time points for which the parameters should be returned.
If "all", returns parameters for all time steps. Default: 1.}

\item{\code{new_data}}{Optional data set of covariates. If \code{new_data},
\code{X_fe} and \code{X_re} are not provided, then the observed 
covariates are used.}

\item{\code{X_fe}}{Optional design matrix for fixed effects, as returned
by \code{make_mat}. By default, uses design matrix from data.}

\item{\code{X_re}}{Optional design matrix for random effects, as returned
by \code{make_mat}. By default, uses design matrix from data.}

\item{\code{coeff_fe}}{Optional vector of fixed effect parameters}

\item{\code{coeff_re}}{Optional vector of random effect parameters}

\item{\code{resp}}{Logical (default: TRUE). Should the output be on 
the response scale? If FALSE, the output is on the linear 
predictor scale}

\item{\code{term}}{Name of model term as character string, e.g., "time", 
or "s(time)". Use \code{$coeff_fe()} and \code{$coeff_re()} methods
to find names of model terms. This uses fairly naive substring 
matching, and may not work if one covariate's name is a 
substring of another one.}

\item{\code{re_index}}{index of terms we want to keep in the random effects matrix and coeffs
May create conflicts with param "term" if it is not null.}

\item{\code{ignore_re}}{whether or not to ignore the random effects in the linear predictor}

\item{\code{ignore_fe}}{whether or not to ignore the fixed effects (intercepts)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Matrix with one row for each time point in t, and one
column for each SDE parameter
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-post_coeff"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-post_coeff}{}}}
\subsection{Method \code{post_coeff()}}{
Posterior draws (coefficients)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$post_coeff(n_post)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n_post}}{Number of posterior draws}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Matrix with one column for each coefficient and one row for each
posterior draw
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-post_par"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-post_par}{}}}
\subsection{Method \code{post_par()}}{
Posterior draws of SDE parameters (for uncertainty 
quantification)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$post_par(
  X_fe,
  X_re,
  n_post = 1000,
  resp = TRUE,
  term = NULL,
  re_index = NULL,
  ignore_re = FALSE,
  ignore_fe = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{X_fe}}{Design matrix (fixed effects)}

\item{\code{X_re}}{Design matrix (random effects)}

\item{\code{n_post}}{Number of posterior draws (default: 100)}

\item{\code{resp}}{Logical (default: TRUE). Should the output be on 
the response scale? If FALSE, the output is on the linear 
predictor scale.}

\item{\code{term}}{Name of model term as character string, e.g., "time", 
or "s(time)". Use \code{$coeff_fe()} and \code{$coeff_re()} methods
to find names of model terms. This uses fairly naive substring 
matching, and may not work if one covariate's name is a 
substring of another one.}

\item{\code{re_index}}{index of terms we want to keep in the random effects matrix and coeffs
May create conflicts with param "term" if it is not null.}

\item{\code{ignore_re}}{whether or not to ignore the random effects in the linear predictor}

\item{\code{ignore_fe}}{whether or not to ignore the fixed effects (intercepts)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Array with one row for each time step, one column for
each SDE parameter, and one layer for each posterior draw
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-CI_pointwise"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-CI_pointwise}{}}}
\subsection{Method \code{CI_pointwise()}}{
Pointwise confidence intervals for SDE parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$CI_pointwise(
  t = NULL,
  new_data = NULL,
  X_fe = NULL,
  X_re = NULL,
  level = 0.95,
  n_post = 1000,
  resp = TRUE,
  term = NULL,
  re_index = NULL,
  ignore_re = FALSE,
  ignore_fe = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{t}}{Time points for which the parameters should be returned.
If "all", returns parameters for all time steps. Defaults to 1 if new
data not provided, or "all" if new data provided.}

\item{\code{new_data}}{Optional data frame containing covariate values 
for which the CIs should be computed}

\item{\code{X_fe}}{Optional design matrix for fixed effects, as returned
by \code{make_mat}. By default, uses design matrix from data.}

\item{\code{X_re}}{Optional design matrix for random effects, as returned
by \code{make_mat}. By default, uses design matrix from data.}

\item{\code{level}}{Confidence level (default: 0.95 for 95\% confidence 
intervals)}

\item{\code{n_post}}{Number of posterior samples from which the confidence
intervals are calculated. Larger values will reduce approximation
error, but increase computation time. Defaults to 1000.}

\item{\code{resp}}{Logical (default: TRUE). Should the output be on 
the response scale? If FALSE, the output is on the linear 
predictor scale.}

\item{\code{term}}{Name of model term as character string, e.g., "time", 
or "s(time)". Use \code{$coeff_fe()} and \code{$coeff_re()} methods
to find names of model terms. This uses fairly naive substring 
matching, and may not work if one covariate's name is a 
substring of another one.}

\item{\code{re_index}}{index of terms we want to keep in the random effects matrix and coeffs
May creat conflicts with param "term" if it is not null.}

\item{\code{ignore_re}}{whether or not to ignore the random effects in the linear predictor}

\item{\code{ignore_fe}}{whether or not to ignore the fixed effects (intercepts)

This method generates pointwise confidence intervals 
by simulation. That is, it generates \code{n_post} posterior samples 
of the estimated parameters from a multivariate normal distribution,
where the mean is the vector of estimates and the covariance matrix 
is provided by TMB (using \code{\link{post_par}}). Then, the SDE 
parameters are derived for each set of posterior parameter values, 
and pointwise confidence intervals are obtained as quantiles of the 
posterior simulated SDE parameters.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
List with elements:
\itemize{
  \item{\code{low}}{Matrix of lower bounds of confidence intervals.}
  \item{\code{upp}}{Matrix of upper bounds of confidence intervals.}
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-CI_simultaneous"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-CI_simultaneous}{}}}
\subsection{Method \code{CI_simultaneous()}}{
Simultaneous confidence intervals for SDE parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$CI_simultaneous(
  t = NULL,
  new_data = NULL,
  X_fe = NULL,
  X_re = NULL,
  level = 0.95,
  n_post = 1000,
  resp = TRUE,
  term = NULL,
  re_index = NULL,
  ignore_re = FALSE,
  ignore_fe = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{t}}{Time points for which the parameters should be returned.
If "all", returns parameters for all time steps. Defaults to 1 if new
data not provided, or "all" if new data provided.}

\item{\code{new_data}}{Optional data frame containing covariate values 
for which the CIs should be computed}

\item{\code{X_fe}}{Optional design matrix for fixed effects, as returned
by \code{make_mat}. By default, uses design matrix from data.}

\item{\code{X_re}}{Optional design matrix for random effects, as returned
by \code{make_mat}. By default, uses design matrix from data.}

\item{\code{level}}{Confidence level (default: 0.95 for 95\% confidence 
intervals)}

\item{\code{n_post}}{Number of posterior samples from which the confidence
intervals are calculated. Larger values will reduce approximation
error, but increase computation time. Defaults to 1000.}

\item{\code{resp}}{Logical (default: TRUE). Should the output be on 
the response scale? If FALSE, the output is on the linear 
predictor scale.}

\item{\code{term}}{Name of model term as character string, e.g., "time", 
or "s(time)". Use \code{$coeff_fe()} and \code{$coeff_re()} methods
to find names of model terms. This uses fairly naive substring 
matching, and may not work if one covariate's name is a 
substring of another one.}

\item{\code{re_index}}{index of terms we want to keep in the random effects matrix and coeffs
May creat conflicts with param "term" if it is not null.}

\item{\code{ignore_re}}{whether or not to ignore the random effects in the linear predictor}

\item{\code{ignore_fe}}{whether or not to ignore the fixed effects (intercepts)


This method closely follows the approach suggested by Gavin Simpson at
fromthebottomoftheheap.net/2016/12/15/simultaneous-interval-revisited/,
itself based on Section 6.5 of Ruppert et al. (2003).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
List with elements:
\itemize{
  \item{\code{low}}{Matrix of lower bounds of confidence intervals.}
  \item{\code{upp}}{Matrix of upper bounds of confidence intervals.}
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-residuals"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-residuals}{}}}
\subsection{Method \code{residuals()}}{
Model residuals
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$residuals()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-check_post"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-check_post}{}}}
\subsection{Method \code{check_post()}}{
Posterior predictive checks
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$check_post(
  check_fn,
  model_name = NULL,
  n_sims = 100,
  silent = FALSE,
  save = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{check_fn}}{Goodness-of-fit function which accepts "data" as input
and returns a dataframe of statistics for each individual
(one row per statistic and one column per ID) ,to be compared
between observed data and simulations.}

\item{\code{model_name}}{string for the name of the sde model to be checked. 
Used when save=TRUE. Need to exist a folder with name model_name in the working
directory}

\item{\code{n_sims}}{Number of simulations to perform}

\item{\code{silent}}{Logical. If FALSE, simulation progress is shown. 
(Default: FALSE)}

\item{\code{save}}{whether or not to save the plots in folder model_name}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
List with elements:
\itemize{
  \item{obs_stat}{Vector of values of goodness-of-fit statistics for the
  observed data}
  \item{stats}{Matrix of values of goodness-of-fit statistics for the
  simulated data sets (one row for each statistic, and one column for each
  simulation)}
}
Conditional Akaike Information Criterion

The conditional AIC is for example defined by 
Wood (2017), as AIC = - 2L + 2k where L is the
maximum joint log-likelihood (of fixed and random
effects), and k is the number of effective degrees
of freedom of the model (accounting for flexibility
in non-parametric terms implied by smoothing)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-AIC_conditional"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-AIC_conditional}{}}}
\subsection{Method \code{AIC_conditional()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$AIC_conditional()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Conditional AIC
Marginal Akaike Information Criterion

The marginal AIC is for example defined by 
Wood (2017), as AIC = - 2L + 2k where L is the
maximum marginal log-likelihood (of fixed 
effects), and k is the number of degrees
of freedom of the fixed effect component of
the model
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-AIC_marginal"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-AIC_marginal}{}}}
\subsection{Method \code{AIC_marginal()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$AIC_marginal()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Marginal AIC
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-edf_conditional"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-edf_conditional}{}}}
\subsection{Method \code{edf_conditional()}}{
Effective degrees of freedom
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$edf_conditional()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Number of effective degrees of freedom
(accounting for flexibility in non-parametric 
terms implied by smoothing)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-simulate"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-simulate}{}}}
\subsection{Method \code{simulate()}}{
Simulate from SDE model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$simulate(
  data,
  z0 = 0,
  posterior = FALSE,
  atw = NULL,
  land = NULL,
  sd_noise = NULL,
  omega_times = 1,
  verbose = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{Data frame for input data. Should have at least one column 'time' for
times of observations, and columns for covariates if necessary.}

\item{\code{z0}}{Optional values for first observations of simulated time series.
Can be a matrix with n_dim columns and n_id rows or a single value that will be repeated
for each initial position in each dimension
Default: 0.}

\item{\code{posterior}}{Logical. If TRUE, the parameters used for the simulation
are drawn from their posterior distribution using \code{SDE$post_coeff}, 
therefore accounting for uncertainty.}

\item{\code{atw}}{(along the way) Covariates to recompute along the way using the previous velocity and position.
This should be a list with names matching some covariates in self$formulas() and with elements that 
are functions to compute the covariate value from the last position, velocity and nearest point on the boundary (if needed).
If some covariate is not in the list, values in argument "data" are used.
If NULL, covariate values in "data" are used.}

\item{\code{land}}{polygon data for defining the land (or any constrained domain)
WARNING : Coordinates should be in the same CRS and same unit (UTM or Long Lat) for land polygons and initial position}

\item{\code{sd_noise}}{standard deviation to add gaussian noise in the observations. Default: NULL (no noise)}

\item{\code{omega_times}}{coefficient to multiply omega in RACVM.Default: 1}

\item{\code{verbose}}{If TRUE, verbose mode}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Input data frame with extra column for simulated time series
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-plot_par"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-plot_par}{}}}
\subsection{Method \code{plot_par()}}{
Plot observation parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$plot_par(
  var,
  par_names = NULL,
  covs = NULL,
  n_post = 100,
  show_CI = "none",
  resp = TRUE,
  term = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{var}}{Name of covariate as a function of which the parameters
should be plotted}

\item{\code{par_names}}{Optional vector for the names of SDE parameters to plot.
If not specified, all parameters are plotted.}

\item{\code{covs}}{Optional data frame with a single row and one column
for each covariate, giving the values that should be used. If this is
not specified, the mean value is used for numeric variables, and the
first level for factor variables.}

\item{\code{n_post}}{Number of posterior draws to plot. Default: 100.}

\item{\code{show_CI}}{Should confidence bands be plotted rather than posterior
draws? Can takes values 'none' (default; no confidence bands), 
'pointwise' (show pointwise confidence bands obtained with
\code{\link{CI_pointwise}}), or 'simultaneous' (show simultaneous 
confidence bands obtained with \code{\link{CI_simultaneous}})}

\item{\code{resp}}{Logical (default: TRUE). Should the output be on 
the response scale? If FALSE, the output is on the linear 
predictor scale.}

\item{\code{term}}{Name of model term as character string, e.g., "time", 
or "s(time)". Use \code{$coeff_fe()} and \code{$coeff_re()} methods
to find names of model terms. This uses fairly naive substring 
matching, and may not work if one covariate's name is a 
substring of another one.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A ggplot object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-plot_violin_coeff"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-plot_violin_coeff}{}}}
\subsection{Method \code{plot_violin_coeff()}}{
when there are no fixed effect and a single or no random effect,
create violin plot for the posterior of the paremeter "par".
Works only for formula of the form "par=~s(ID,bs="re")" or "par=~1"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$plot_violin_coeff(
  model_name,
  substring = NULL,
  true_coeff = NULL,
  save = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{model_name}}{name of the SDE model, used as the directory name where the plots should be saved}

\item{\code{substring}}{substring contained in the coeff names that we want to plot. If it is some parameter name, 
then only the coeff involved in this parameter are plotted. If NULL, all coeffs are plotted.}

\item{\code{true_coeff}}{dataframe with two columns "value" for the true value of the coeff and "name" for the name of the coeff.}

\item{\code{save}}{boolean to save the plots or not}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-plot_violin_par"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-plot_violin_par}{}}}
\subsection{Method \code{plot_violin_par()}}{
when there are no fixed effect and a single or no random effect,
create violin plot for the posterior of the paremeter "par".
Works only for formula of the form "par=~s(ID,bs="re")" or "par=~1"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$plot_violin_par(model_name, par, save = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{model_name}}{name of the SDE model, used as the directory name where the plots should be saved}

\item{\code{par}}{string matching with one parameter name in the sde}

\item{\code{save}}{boolean to save the plots or not}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-plot_fe_par_2D"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-plot_fe_par_2D}{}}}
\subsection{Method \code{plot_fe_par_2D()}}{
plot the fixed effect for a parameter that depends only on one fixed effect covariate,
or on two orthogonal covariates in a sde model. 
The function might be extended to multiple orthogonal covariates.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$plot_fe_par_2D(
  baseline = NULL,
  model_name,
  par,
  npoints = 200,
  xmin,
  xmax,
  link,
  xlabel,
  show_CI = "none",
  ignore_intercept = FALSE,
  true_smooth = NULL,
  save = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{baseline}}{a fitted baseline sde model without fixed effect. If not NULL, the baseline values with CI
appear on the plots}

\item{\code{model_name}}{name of the SDE model, used as the directory name where the plots should be saved}

\item{\code{par}}{the name of the parameter we want to plot}

\item{\code{npoints}}{number of points for the plot}

\item{\code{xmin}}{minimum value of the covariate to plot}

\item{\code{xmax}}{maximum value of the covariate to plot}

\item{\code{link}}{function to link the covariate to the quantity we want to have on the x-axis in the plots}

\item{\code{xlabel}}{label for the quantity in the xaxis for the plot}

\item{\code{show_CI}}{string "none", "pointwise" or "simultaneous". Simultaneous CI do not work for the moment}

\item{\code{ignore_intercept}}{whether or not to ignore the fixed effects (intercepts)}

\item{\code{true_smooth}}{function that takes a dataframe of covariate values and return a dataframe of true values of the parameter}

\item{\code{save}}{boolean to save or not to save the plots}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-plot_me_par_2D"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-plot_me_par_2D}{}}}
\subsection{Method \code{plot_me_par_2D()}}{
function to plot the estimates for each individual (taking into account one single random effect) 
for a parameter that depends only on one fixed effect covariate, or on two orthogonal covariates
 in a sde model. The function might be extended to multiple orthogonal covariates.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$plot_me_par_2D(
  baseline = NULL,
  model_name,
  par,
  npoints = 200,
  xmin,
  xmax,
  link,
  xlabel,
  ignore_intercept = FALSE,
  show_CI,
  save = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{baseline}}{is a baseline model without fixed effects to be compared to (default is NULL).}

\item{\code{model_name}}{string to put in the name of the saved plots}

\item{\code{par}}{name of the parameter we want to plot}

\item{\code{npoints}}{number of points where the smooth population function is plotted}

\item{\code{xmin}}{min values of the covariates to plot the parameters. If NULL, then we take the min
of the observed values of each covariate}

\item{\code{xmax}}{max values of the covariates to plot the parameters. If NULL, then we take the max
of the observed values of each covariate}

\item{\code{link}}{function that links the covariate and the quantity appearing in the x axis of the plots}

\item{\code{xlabel}}{the label of the x-axis in the plots}

\item{\code{ignore_intercept}}{whether or not to ignore the fixed effects (intercepts)}

\item{\code{show_CI}}{string "none", "pointwise" or "simultaneous". Simultaneous CI do not work for the moment}

\item{\code{save}}{boolean}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-plot_fe_par_3D"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-plot_fe_par_3D}{}}}
\subsection{Method \code{plot_fe_par_3D()}}{
3D plot of a parameter when there are two non orthogonal covariates and at most one random effect
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$plot_fe_par_3D(
  baseline = NULL,
  model_name,
  par,
  npoints = 50,
  xmin,
  xmax,
  link,
  xlabel,
  show_CI = "none",
  probs = c(0.05, 0.25, 0.5, 0.75, 0.95),
  true_smooth = NULL,
  save = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{baseline}}{is a baseline model without fixed effects to be compared to (default is NULL).}

\item{\code{model_name}}{string to put in the name of the saved plots}

\item{\code{par}}{name of the parameter we want to plot}

\item{\code{npoints}}{number of points where the smooth population function is plotted}

\item{\code{xmin}}{min values of the covariates to plot the parameters.}

\item{\code{xmax}}{max values of the covariates to plot the parameters.}

\item{\code{link}}{function that links the covariate and the quantity appearing in the x axis of the plots}

\item{\code{xlabel}}{the label of the x-axis in the plots}

\item{\code{show_CI}}{string "none", "pointwise" or "simultaneous". Simultaneous CI do not work for the moment.
If it is not "none", then 2D plots with confidence intervals of each covariate while the other is fixed at the quantiles
values are created.}

\item{\code{probs}}{quantile probabilities for the plots where one of the covariate is fixed}

\item{\code{true_smooth}}{Default : NULL, otherwise a function that gives the true value of the parameter "par" depending
on the relevant covariates}

\item{\code{save}}{boolean}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-get_all_plots"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-get_all_plots}{}}}
\subsection{Method \code{get_all_plots()}}{
get all the plots of the estimates of the parameters according to the model formulas
for each parameter :
- if there are no fixed effects, we create violin plots for the parameter estimates
 - If there is only one fixed effect, we plot the fixed effect estimates and the mixed effects (if there is one random effect) on two different plots
 - If there are two fixed effects, two cases are possible :
      . either the covariates are orthogonal, in which case we plot the fixed effects (and 
        the mixed effects if there is one random effect) for each covariate while forcing the other to 0
      . or they are not orthogonal, in which case we plot the fixed effects in 3D, and
        we plot each covariate while setting the values of the others to the observed quantiles.
In any other case, we plot each covariate while setting the values of the others to the observed quantiles (NOT DONE YET)
Extraction of the covariate names from the formulas is based on regular expressions and may not work for some specific cases. If it happens,
using function plot_par instead is recommended.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$get_all_plots(
  baseline = NULL,
  model_name,
  link = list(),
  xmin = list(),
  xmax = list(),
  xlabel = list(),
  show_CI = "none",
  ignore_intercept = FALSE,
  true_smooths = NULL,
  save = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{baseline}}{baseline sde model to be compared to (default is NULL). 
It Should be given as an entry if we want to plot baseline intercepts on the smooth functions graph}

\item{\code{model_name}}{string name for the sde model, to be chosen by the user. Used for the filenames to save the plots}

\item{\code{link}}{list of functions that links the fixed effect covariates and the quantity appearing in the axis of the plots.        #' 
The names of the list is a subset of the names of all the covariates appearing in the formulas.}

\item{\code{xmin}}{list of min values for each fixed effects covariate in the model to plot the parameters.
If NULL, then we take the min of the observed values for each covariate.}

\item{\code{xmax}}{list of max values for each fixed effects covariate in the model to plot the parameters.
If NULL, then we take the max of the observed values for each covariate.}

\item{\code{xlabel}}{list of labels for the axis of the plot for each covariate.}

\item{\code{show_CI}}{string to indicate the type of CI. "none", "simultaneous" or "pointwise". 
Simultaneous CI do not work for the moment.}

\item{\code{ignore_intercept}}{whether or not to ignore the fixed effects (intercepts)}

\item{\code{true_smooths}}{Default : NULL, otherwise a list of functions for each smooth parameter,
that takes in entry a dataframe of covariates and give the true value of the parameters depending on the relevant covariates}

\item{\code{save}}{boolean}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
list of ggplot objects
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-ind_fixcoeff"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-ind_fixcoeff}{}}}
\subsection{Method \code{ind_fixcoeff()}}{
Indices of fixed coefficients in coeff_fe
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$ind_fixcoeff()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-eqn"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-eqn}{}}}
\subsection{Method \code{eqn()}}{
Print equation for this model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$eqn()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-message"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-message}{}}}
\subsection{Method \code{message()}}{
Print SDE and parameter formulas
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$message()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-print_par"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-print_par}{}}}
\subsection{Method \code{print_par()}}{
Print parameter values for t = 1
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$print_par()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-print"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-print}{}}}
\subsection{Method \code{print()}}{
Print SDE object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-stationary"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-stationary}{}}}
\subsection{Method \code{stationary()}}{
Print stationary distribution
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$stationary()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SDE-clone"></a>}}
\if{latex}{\out{\hypertarget{method-SDE-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SDE$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
